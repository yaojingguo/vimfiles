set nocompatible
" set gfn=Ubuntu\ Mono\ 20
"set gfn=Droid\ Sans\ Mono\ 19
"set gfn=Droid\ Sans\ Mono\ Slashed\ 19
"set gfn=Inconsolata\ 16
"set gfn=Courier\ New\ 29
"set gfn=Inconsolata\ Medium\ 17

" Works for vim. But does not work for mvim.
"set gfn=RobotoMonoForPowerline:h19

"set gfn=RobotoMonoForPowerline-Light:h17
"set gfn=RobotoMonoForPowerline-Regular:h17
"set gfn=SourceCodeProForPowerline-Regular:h17
"set gfn=FiraCode-Regular:h17
set gfn=FiraCode-Regular:h16
"set gfn=Fira\ Code\ Retina:h16
"set gfn=Fira\ Code\ Retina:h16
" set gfn=JetBrains\ Mono:h15
" set gfn=Hack:h16
"set gfn=Monaco:h18
" set gfn=Monospace:h16
"set gfn=ProggyClean\ 12
"let g:rehash256 = 1
"color molokai
"

" set macligatures
" set guifont=Fira\ Code:h19

command XXDR %s#^[^:]*: \(\%\(\x\+ \)\+\) .*#\1# | %!xxd -r -p

" let g:vimtex_enabled=0
" let g:vimtex_quickfix_ignore_all_warnings=1

let g:rainbow_active = 1

set mmp=2000

set hls
"set cursorline
syntax enable
"set ic
set autoread


" execute pathogen#infect()
filetype off                  " required
" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')

" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'
Plugin 'robbles/logstash.vim'
Plugin 'mileszs/ack.vim'
Plugin 'FelikZ/ctrlp-py-matcher'
Plugin 'ctrlpvim/ctrlp.vim'
Plugin 'morhetz/gruvbox'
Plugin 'scrooloose/nerdcommenter'
Plugin 'scrooloose/nerdtree'
Plugin 'mhartington/oceanic-next'
Plugin 'sonph/onehalf'
Plugin 'rhysd/vim-llvm'
Plugin 'tpope/vim-vinegar'
" Plugin 'luochen1990/rainbow'
Plugin 'itkq/fluentd-vim'
Plugin 'AndrewRadev/splitjoin.vim'
Plugin 'godlygeek/tabular'
Plugin 'majutsushi/tagbar'
Plugin 'leafgarland/typescript-vim'
Plugin 'SirVer/ultisnips'
Plugin 'tpope/vim-abolish'
Plugin 'bling/vim-airline'
Plugin 'vim-airline/vim-airline-themes'
Plugin 'altercation/vim-colors-solarized'
Plugin 'tpope/vim-fugitive'
Plugin 'tikhomirov/vim-glsl'
Plugin 'fatih/vim-go'
Plugin 'tfnico/vim-gradle'
Plugin 'pangloss/vim-javascript'
Plugin 'MaxMEllon/vim-jsx-pretty'
Plugin 'peitalin/vim-jsx-typescript'
Plugin 'tpope/vim-markdown'
Plugin 'Harenome/vim-mipssyntax'
Plugin 'jceb/vim-orgmode'
Plugin 'derekwyatt/vim-scala'
Plugin 'honza/vim-snippets'
Plugin 'tpope/vim-speeddating'
Plugin 'lervag/vimtex'
Plugin 'HerringtonDarkholme/yats.vim'
Plugin 'yaojingguo/ir_black'
Plugin 'jparise/vim-graphql'
Plugin 'whonore/Coqtail'

Plugin 'vim-python/python-syntax'

Plugin 'junegunn/seoul256.vim'
Plugin 'junegunn/goyo.vim'

Plugin 'joshdick/onedark.vim'
" Plugin 'airblade/vim-rooter'


" Add maktaba and codefmt to the runtimepath.
" (The latter must be installed before it can be used.)
Plugin 'google/vim-maktaba'
Plugin 'google/vim-codefmt'
" Also add Glaive, which is used to configure codefmt's maktaba flags. See
" `:help :Glaive` for usage.
Plugin 'google/vim-glaive'

Plugin 'junegunn/fzf.vim'
Plugin 'KeitaNakamura/neodark.vim'
Plugin 'Joorem/vim-haproxy'

" All of your Plugins must be added before the following line
call vundle#end()            " required


" " Mapping selecting mappings
" nmap <leader><tab> <plug>(fzf-maps-n)
" xmap <leader><tab> <plug>(fzf-maps-x)
" omap <leader><tab> <plug>(fzf-maps-o)

" " Insert mode completion
" imap <c-x><c-k> <plug>(fzf-complete-word)
" imap <c-x><c-f> <plug>(fzf-complete-path)
" imap <c-x><c-l> <plug>(fzf-complete-line)


" the glaive#Install() should go after the "call vundle#end()"
call glaive#Install()
" Optional: Enable codefmt's default mappings on the <Leader>= prefix.
Glaive codefmt plugin[mappings]
Glaive codefmt google_java_executable="java -jar /Users/jing/tools/google-java-format-1.9-all-deps.jar"
Glaive codefmt clang_format_style="google"

filetype plugin indent on
syntax on

set wildignore+=node_modules
set wildignore+=bower_components
set wildignore+=build-eclipse
set wildignore+=build
set wildignore+=target


"tab page configuration
map <C-S-]> gt
map <C-S-[> gT
map <C-1> 1gt
map <C-2> 2gt
map <C-3> 3gt
map <C-4> 4gt
map <C-5> 5gt
map <C-6> 6gt
map <C-7> 7gt
map <C-8> 8gt
map <C-9> 9gt
map <C-0> :tablast<CR>

set laststatus=2

set scroll=10

" GO
" au Filetype go nnoremap <leader>g :exe "GoDef" <CR>
" au Filetype go nnoremap <leader>gv :vsp <CR>:exe "GoDef" <CR>
" au Filetype go nnoremap <leader>gs :sp <CR>:exe "GoDef"<CR>
" au Filetype go nnoremap <leader>gt :tab split <CR>:exe "GoDef"<CR>
au Filetype go nnoremap <leader>g :GoReferrers<CR>
" let g:go_fmt_autosave = 0
let g:go_asmfmt_autosave = 0
" let g:go_def_mode = 'godef'

let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_structs = 1
let g:go_highlight_build_constraints = 1
" let g:go_highlight_fields = 1
autocmd FileType go set number fo+=croq tw=80
autocmd Filetype go set makeprg=go\ build\ .

" let g:go_fmt_command = "goimports"
let g:go_fmt_options = {
  \ 'gofmt': '-s',
  \ }

" let g:go_fmt_options = {
"   \ 'gofmt': '-s',
"   \ 'goimports': '-w',
"   \ }


nnoremap <C-A> :CtrlPBuffer<CR>
nnoremap <C-S> :CtrlPMRU<CR>

"This returns the 1-based offset in file, which is the same as %o in
"statusline. For details, refer to https://vi.stackexchange.com/a/3850/15649
function! FileOffset()
  return line2byte(line('.')) + col('.') - 1
endfunction


let g:airline_extensions = []
" let g:airline#extensions#syntastic#enabled = 0


"set statusline+=%#warningmsg#
"set statusline+=%{SyntasticStatuslineFlag()}
"set statusline+=%*


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Syntastic is removed since it conflicts with GoReferrers in go-vom.
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"command Sc :SyntasticCheck
"command Sr :SyntasticReset
"command St :SyntasticToggleMode
"let g:syntastic_html_tidy_exec = '/home/jing/tools/tidy-html5/bin/tidy'
"let g:syntastic_always_populate_loc_list = 1
"let g:syntastic_auto_loc_list = 1
"let g:syntastic_check_on_open = 1
"let g:syntastic_check_on_wq = 0
"let g:syntastic_go_checkers = ['golint', 'govet', 'errcheck']
"let g:syntastic_mode_map = { 'mode': 'active',
"                           \ 'passive_filetypes': ['java', 'go'] }

"ctrlp
let g:ctrlp_working_path_mode = 'a'
let g:ctrlp_follow_symlinks = 2

let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }

let g:ctrlp_max_files = 0

ab Tablularize Tab

"Show filename
set guitablabel=%M\ %t

" "snippets
" " Trigger configuration. Do not use <tab> if you use https://github.com/Valloric/YouCompleteMe.
" let g:UltiSnipsExpandTrigger="<tab>"
" let g:UltiSnipsJumpForwardTrigger="<c-b>"
" let g:UltiSnipsJumpBackwardTrigger="<c-z>"

" " If you want :UltiSnipsEdit to split your window.
" let g:UltiSnipsEditSplit="vertical"


function Maximize_Window()
  silent !wmctrl -r :ACTIVE: -b add,maximized_vert,maximized_horz
endfunction

function Path(flag)
  if a:flag == 0
    set path=.,/usr/include,
  else
    set path=.,/usr/include,**,
  endif
endfunction

let g:table_mode_motion_prefix = '<Leader>u'

let mapleader = ","
let maplocalleader = ","

hi CursorLine   cterm=NONE ctermbg=darkred ctermfg=white guibg=darkred guifg=white
":hi CursorColumn cterm=NONE ctermbg=darkred ctermfg=white guibg=darkred guifg=white
map <Leader>hh :set cursorline!<CR>

set undodir=/home/jing/.tmp-jing/vim-undodir
set undofile
set undolevels=1000 "maximum number of changes that can be undone
set undoreload=10000 "maximum number lines to save for undo on a buffer reload


set fileencodings=utf-8,gb2312,gbk,gb18030
set termencoding=utf-8
"set encoding=prc
set encoding=utf-8

command Thtml :%!tidy -q -i -html
command Txml  :%!tidy -q -i -xml

set nowrap

"json indent
" map <leader>jf  <Esc>:%!python3 -m json.tool<CR>
map <leader>jf  <Esc>:%!jq<CR>

let g:python_highlight_all = 1

"vimclojure
let vimclojure#NailgunClient="ng"
"let vimclojure#WantNailgun = 1
map <leader>ng :let vimclojure#WantNailgun=1<CR>


"latex-suite
"let g:Tex_DefaultTargetFormat='pdf'
"noremap <silent> <D-V> <Esc>:BuildAndViewTexPdf<CR>
"inoremap <silent> <D-V> <Esc>:BuildAndViewTexPdf<CR>
"noremap <silent> <D-T> <Esc>:BuildTexPdf<CR>
"inoremap <silent> <D-T> <Esc>:BuildTexPdf<CR>
"let g:tex_pdf_map_leader_keys = 0

"set splitbelow
set linebreak

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" tag list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let Tlist_Show_One_File = 1

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Command mode related
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Smart mappings on the command line
cno $og cs find g
cno $o cs find
cno $so cs find
cno $vo cs find
cno $h e ~/
"cno $d e ~/Desktop/
cno $j e ./
cno $c e <C-\>eCurrentFileDir("e")<cr>

" $q is super useful when browsing on the command line
cno $q <C-\>eDeleteTillSlash()<cr>

" Bash like keys for the command line
" cnoremap <C-A> <Home>
" cnoremap <C-E> <End>
" cnoremap <C-K> <C-U>
" cnoremap <C-P> <Up>
" cnoremap <C-N> <Down>

func! Cwd()
  let cwd = getcwd()
  return "e " . cwd
endfunc

func! DeleteTillSlash()
  let g:cmd = getcmdline()
  if MySys() == "linux" || MySys() == "mac"
    let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*", "\\1", "")
  else
    let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\]\\).*", "\\1", "")
  endif
  if g:cmd == g:cmd_edited
    if MySys() == "linux" || MySys() == "mac"
      let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*/", "\\1", "")
    else
      let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\\]\\).*\[\\\\\]", "\\1", "")
    endif
  endif
  return g:cmd_edited
endfunc

func! CurrentFileDir(cmd)
  return a:cmd . " " . expand("%:p:h") . "/"
endfunc

""""""""""""""""""""""""""""""""""""""""""""""
" Haskell
""""""""""""""""""""""""""""""""""""""""""""""
"au BufEnter *.hs compiler ghc
let g:haddock_browser = "/opt/google/chrome/google-chrome"
let g:haddock_docdir="/usr/share/doc/ghc6-doc/html"
let g:haddock_indexfiledir="/home/jing/.vim/"

" move around windows
map <C-j> <C-W>j
map <C-k> <C-W>k
map <C-h> <C-W>h
map <C-l> <C-W>l


" Tab configuration
map <leader>tn :tabnew<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove<cr>

" Use the arrows to something useful
"map <right> :bn<cr>
"map <left> :bp<cr>

" When pressing <leader>cd switch to the directory of the open buffer
map <leader>cd :cd %:p:h<cr>

""""""""""""""""""""""""""""""
" => Minibuffer plugin
""""""""""""""""""""""""""""""
"let g:miniBufExplModSelTarget = 1
"let g:miniBufExplorerMoreThanOne = 2
"let g:miniBufExplModSelTarget = 0
"let g:miniBufExplUseSingleClick = 1
"let g:miniBufExplMapWindowNavVim = 1
"let g:miniBufExplVSplit = 25
"let g:miniBufExplSplitBelow=1

""""""""""""""""""""""""""""""
" => MRU plugin
""""""""""""""""""""""""""""""
let MRU_Max_Entries = 400
map <leader>f :MRU<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Cope
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Do :help cope if you are unsure what cope is. It's super useful!
map <leader>cc :botright cope<cr>
map <leader>cn :cn<cr>
map <leader>cp :cp<cr>


"Clojure
let vimclojure#HighlightBuiltins=1
let vimclojure#ParenRainbow=1

"nerdcommenter
"let NERDRemoveExtraSpaces=0
 let NERDSpaceDelims=1
autocmd BufEnter * call SetNERD()
map <Leader>d :NERDTreeToggle<CR>
map <leader>w :NERDTree .<CR>
" let NERDTreeIgnore = ['tmp', 'tags', 'a.out', 'yfs1', 'yfs2', '\~$', '\.aux$', '\.eps$'
"       \'\.pyc$', '\.hi$', '\.os$', 'cscope.*$', '\.o$',
"       \'^buildEclipse$', 
"       \'\.class$',
"       \'bower_components$', 'node_modules$', 'build-eclipse']
" \'^target$', 

function! SetPython()
  call SetLocalTab(2)
  let g:NERDTreeIgnore += ['\.pdf$', '\.tex$', '\.html$', '\.log$', '\.txt$']
endfunction

function! SetNERD() 
  " NERDTreeFocus
  " NERDTreeMirror
endfunction


set wildignore+=*.o,*.obj,.git,*.class,*.hi,CVS,*.d

set guioptions-=T

function! ResetFuzzy(root)
  let g:fuzzy_roots = [a:root]
  call InstantiateTextMateMode()
endfunction

command! -complete=dir -nargs=* Rft :call ResetFuzzy(<f-args>)
"map <leader>t :FuzzyFinderTextMate<CR>


function! Txt(width)
  "set syn=txt
  execute "setlocal tw=".a:width
  set ai
  "set formatoptions=tcnqaw
  "set formatoptions=tcnqw
  set formatoptions=tcnq
endfunction

set nu
"set spell


vmap c "+y
map <leader>v  "+gp
"map <leader>v  "+gP


nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk

set directory=~/.tmp-jing/vim
set backupdir=~/.tmp-jing/vim

"set makeprg=g++\ -pthread\ -std=c++0x\ %
set makeprg=g++\ -pthread\ %
map <F5> :call Compile()<CR>
map <F7> :call Run()<CR>

func! Compile()
  exec "w"
  exec "make"
endfunc

func! Run()
  exec "!./a.out"
endfunc


"let g:SuperTabMappingForward = '<c-space>'
"let g:SuperTabMappingBackward = '<s-c-space>'


imap <c-space> <c-p>
imap <c-space> <c-n>
imap <C-@> <C-Space>

map! <C-F> <Esc>gUiw`]a

"set tab
function! SetTab(num)
  call SetTabSize(a:num)
  set expandtab
endfunction

function! SetTabSize(num)
  execute "set tabstop=".a:num
  execute "set softtabstop=".a:num
  execute "set shiftwidth=".a:num
endfunction

function! SetLocalTab(num)
  execute "setlocal tabstop=".a:num
  execute "setlocal softtabstop=".a:num
  execute "setlocal shiftwidth=".a:num
	set expandtab
endfunction

call SetTab(2)
" set tabstop=4
" set softtabstop=4
" set shiftwidth=4

function! ST(title)
  "let &g:titlestring=a:title
  let &g:titlestring= a:title . " %t%(\ %M%)%(\ (%{expand(\"%:~:.:h\")})%)%(\ %a%)"
endfunction


"gotags
nmap <leader>go :!gotags -R . >tags<CR><CR>
nmap <F8> :TagbarToggle<CR>
let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:package',
        \ 'i:imports:1',
        \ 'c:constants',
        \ 'v:variables',
        \ 't:types',
        \ 'n:interfaces',
        \ 'w:fields',
        \ 'e:embedded',
        \ 'm:methods',
        \ 'r:constructor',
        \ 'f:functions'
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 't' : 'ctype',
        \ 'n' : 'ntype'
    \ },
    \ 'scope2kind' : {
        \ 'ctype' : 't',
        \ 'ntype' : 'n'
    \ },
    \ 'ctagsbin'  : 'gotags',
    \ 'ctagsargs' : '-sort -silent'
\ }


"set formatlistpat=^\\s*\\*?\\s*\\d\\+[\\]:.)}\\t\ ]\\s*

function! SetC()
  " call SetLocalTab(4)
  setlocal noic
  setl formatoptions-=ro " not to automatically insert comment leader
  setl formatoptions-=t
  setl formatoptions+=ncq

  setl tw=100
endfunction

function! SetGo()
  setl formatoptions-=t
  setl formatoptions-=o
endfunction

autocmd BufRead,BufNewFile *.java call SetJava()
autocmd BufRead,BufNewFile *.go call SetGo()
autocmd BufRead,BufNewFile *.txt,*tex,*.md,README call Txt(80)
autocmd BufRead,BufNewFile *.mail call Txt(70)
autocmd BufRead,BufNewFile SConstruct :set syn=python
autocmd BufRead,BufNewFile *.cc,*.cpp,*.c,*.h,*.S call SetC()
autocmd BufRead,BufNewFile *.py call SetPython()
autocmd BufNewFile,BufRead *.cc11,*.h11 set syntax=cpp11
autocmd BufNewFile,BufRead *.tla set syntax=tla
autocmd BufNewFile,BufRead *.vs,*.fs set syntax=glsl
autocmd BufRead,BufNewFile *.tex :setl tw=120
autocmd BufRead,BufNewFile fluent.conf set syntax=fluentd


function! SetJava()
  call SetLocalTab(2)
  setlocal tw=80
  "setlocal tags+=./tags
  setlocal tags+=/Users/jing/code/github/languages/java/jdk1.8.0_162-src/tags
  setlocal noic
  " set includeexpr=""
  set isfname-=.
  "setlocal foldmethod=expr
  "setlocal foldexpr=getline(v:lnum)[0:5]==\"import\"
  "setlocal formatoptions-=r
  "syn keyword javaExternal native package
  "setlocal foldmethod=syntax
  "setlocal foldnestmax=2
  "syntax region foldImports start=/\(^\s*\n^import\)\@<= .\+;/ end=+^\s*$+ transparent fold keepend
endfunction

let g:godef_split=0

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"cscope
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set cscopetag

function! CreateScope()
  "!find -name '*.[chsS]' > cscope.files
	"!cscope -b -k -q
  "!cscope -b -q
  cs reset
endfunction

if has("cscope")
  set csprg=cscope
  set csto=0

  set cscopequickfix=s-,c-,d-,i-,t-,e-,g-
  " add any database in current directory
  if filereadable("cscope.out")
      cs add cscope.out
      "set cst
  " else add database pointed to by environment
  elseif $CSCOPE_DB != ""
      cs add $CSCOPE_DB
  endif
  set csverb

  nmap <leader>or :call CreateScope()<CR><CR>

  nmap <leader>ox :cs find
  nmap <leader>sox :cs find
  nmap <leader>vox :cs find

  " mapping
  nmap <leader>os :cs find s <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>og :cs find g <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>oc :cs find c <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>ot :cs find t <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>oe :cs find e <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>of :cs find f <C-R>=expand("<cfile>")<CR><CR>
  nmap <leader>oi :cs find i <C-R>=expand("<cfile>")<CR><CR>
  nmap <leader>od :cs find d <C-R>=expand("<cword>")<CR><CR>

  nmap <leader>sos :scs find s <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>sog :scs find g <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>soc :scs find c <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>sot :scs find t <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>soe :scs find e <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>sof :scs find f <C-R>=expand("<cfile>")<CR><CR>
  nmap <leader>soi :scs find i <C-R>=expand("<cfile>")<CR><CR>
  nmap <leader>sod :scs find d <C-R>=expand("<cword>")<CR><CR>

  nmap <leader>vos :vert scs find s <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>vog :vert scs find g <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>voc :vert scs find c <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>vot :vert scs find t <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>voe :vert scs find e <C-R>=expand("<cword>")<CR><CR>
  nmap <leader>vof :vert scs find f <C-R>=expand("<cfile>")<CR><CR>
  nmap <leader>voi :vert scs find i <C-R>=expand("<cfile>")<CR><CR>
  nmap <leader>vod :vert scs find d <C-R>=expand("<cword>")<CR><CR>

  "nmap <C-\>s :cs find s <C-R>=expand("<cword>")<CR><CR>
  "nmap <C-\>g :cs find g <C-R>=expand("<cword>")<CR><CR>
  "nmap <C-\>c :cs find c <C-R>=expand("<cword>")<CR><CR>
  "nmap <C-\>t :cs find t <C-R>=expand("<cword>")<CR><CR>
  "nmap <C-\>e :cs find e <C-R>=expand("<cword>")<CR><CR>
  "nmap <C-\>f :cs find f <C-R>=expand("<cfile>")<CR><CR>
  "nmap <C-\>i :cs find i <C-R>=expand("<cfile>")<CR><CR>
  "nmap <C-\>d :cs find d <C-R>=expand("<cword>")<CR><CR>
  "cnoreabbrev <expr> csa
  "      \ ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs add'   : 'csa')
  "cnoreabbrev <expr> csf
  "      \ ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs find'  : 'csf')
  "cnoreabbrev <expr> csk
  "      \ ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs kill'  : 'csk')
  "cnoreabbrev <expr> csr
  "      \ ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs reset' : 'csr')
  "cnoreabbrev <expr> css
  "      \ ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs show'  : 'css')
  "cnoreabbrev <expr> csh
  "      \ ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs help'  : 'csh')
endif

"xmllint
map <Leader>cd :exe 'cd ' . expand ("%:p:h")<CR>
nmap <Leader>vx <Leader>cd:%w !xmllint --noout -<CR>
nmap <Leader>px :%!xmllint --format -<CR>

" ack.vim
if executable('ag')
  let g:ackprg = 'ag --vimgrep'
endif
noremap <Leader>a :Ack <cword><cr>

au BufNewFile,BufRead *.s set filetype=mips

" Add homebrew fzf to the vim path:
set rtp+=/usr/local/opt/fzf
" nnoremap <silent> <Leader><Space> :Files<CR>
nnoremap <C-i> :Files<CR>
nnoremap <silent> <Leader>ag :Ag <C-R><C-W><CR>
nnoremap <silent> <Leader>rg :Rg <C-R><C-W><CR>

set path=/Users/jing/code/local/include
